function is (x, y) {
  if (x === y) {
      // 运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的
      return x !== 0 || y !== 0 || 1 / x === 1 / y
  } else {
      // NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理
      // 两个都是NaN的时候返回true
      return x !== x && y !== y
  }
}
/*这种相等性判断逻辑和传统的 == 运算不同，
== 运算符会对它两边的操作数做隐式类型转换（如果它们类型不同），然后才进行相等性比较，（所以才会有类似 "" == false 等于 true 的现象）
但 Object.is 不会做这种类型转换。
这与 === 运算符的判定方式也不一样。=== 运算符（和== 运算符）将数字值 -0 和 +0 视为相等，
并认为 Number.NaN 不等于 NaN。*/