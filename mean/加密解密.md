# 打乱字符串

marchsoftsanyueruanjianxiaozu2006-2020  38

由大小写字母加数字组成共61个打乱

```java
String allPassword = abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789;

List<String> stringList =  Arrays.asList("allPassword".split(""));
Collections.shuffle(stringList);
stringList.forEach(System.out::print);
```

# 选取随机数

```java
 System.out.println( (int)(Math.random()*61) );
```

# 抽出项目密码对应字典

```java
int numPassword= (int)(Math.random()*61);
String strPassword;
if(numPassword > 43){
    strPassword += allPassword.substring(numPassword,61-numPassword) + allPassword.substring(0,numPassword-43);
}else{
    strPassword += allPassword.substring(numPassword,numPassword+18);
}
```

# 密码学发展

纵观密码学的发展史，它共经历了三个阶段，分别是手工加密阶段、机械加密阶段和计算机加密阶段。手工加密阶段最为漫长，期间孕育了古典密码，这为后期密码学的发展奠定了基础。机械工业革命发展的同时促进着各种科学技术的进步，密码学也不例外。加之两次世界大战，更加促进了密码学的飞速发展，密码学由此进入现代密码学阶段。尽管如此，在这一阶段的密码学仍旧未能摆脱古典密码学的影子，加密与解密操作均依赖于语言学的支持，转轮密码机Enigma的发明与破解更是将这一特点发挥到了极致。随着数据理论逐步介入，密码学逐渐成为一门学科，而非一门艺术。进入计算机加密阶段后，密码学应用不再局限于军事、政治和外交领域，逐步扩大到商务、金融和社会的其他领域。密码学的研究和应用已大规模扩展到了民用方面。

   密码学主要包含两个分支：密码编码学和密码分析学。密码编码学针对于信息如何隐藏；密码分析学针对于信息如何破译。编码学与分析学相互影响，共同促进密码学的发展。
    古典密码是现代密码的基础，移位和替代是古典密码最常用、最核心的两种加密技巧。由此，古典密码主要分为移位密码和替代密码。例如，凯撒密码就是替代密码的典范。替代密码其分支众多，包含单表替代密码、同音替代密码、多表替代密码和多字母替代密码。移位和替代技巧仍是现代密码学最常用的两种加密手段。

# 现代密码学中的柯克霍夫原则

1. 即使非数学上不可破解，系统也应在实质（应用）程度上无法破解。
2. 系统内不应含任何机密物，即使落入敌人手中也不会造成困扰。
3. 密钥必须易于沟通和记忆，而无需写下，且双方可以很容易地改变密钥。
4. 系统应可以用于电讯。
5. 系统应可以携带，不应需要两个人或两个人以上才能使用（应只要一个人就能使用）。
6. 系统应容易使用，不致让使用者的脑力过分操劳，也无须记得长串的规则。

# 密码体制划分

 从密码体制上划分，现代密码学工分为两种密码体制：堆成密码体制和非对称密码体制。对称与非对称的差别源于加密密钥和解密密钥是否对称，即加密密钥与解密密钥是否相同（对称）。

   在对称密码体制中，加密与解密操作使用相同的密钥，我们把这个密钥称为秘密密钥。DES、AES算法都是常用的对称密码算法。流密码实现简单，对环境要求低，适用于手机平台的加密，广泛应用于军事、外交领域。RC4算法就是典型的流密码算法。流密码的理论、算法受限于国家安全因素未能公布。分组密码在这一点上与流密码恰恰相反，其理论，算法公开，分类众多。DES、AES算法主要的对称密码算法均属于分组密码。分组密码共有5中工作模式：电子密码本模式（ECB）、密文链接模式（CBC）、密文反馈模式（CFB）、输出反馈模式（OFB）、计数器模式（CTR）。分组密码会产生短块，关于短块的处理方法有填充法、流密码加密法、密文挪用技术。
    在非对称密码体制中，加密与解密操作使用不同的密钥。对外公开的密钥，称为公钥；对外保密的密钥，称为私钥。用公钥加密的数据，只能用私钥解密；反之，用私钥加密的数据，只能用公钥解密。RSA算法是常用的非对称密码算法。非对称密码体制同时支持数字签名技术，如RSA、DSA都是常用的数字签名算法。
    散列函数可以有效地确保数据完整性，其是一项消息认证技术。常用的散列函数算法有MD5、SHA、Mac。散列函数也是数字签名技术中最重要的技术环节。数字签名离不开非对称密码体制，其私钥用于签名，公钥用于验证。基于数字签名的不可伪造性，数字签名技术成为5种安全服务中数据完整性服务、认证性服务和抗否认性服务的核心技术。通信双方只有一方提供数字签名的认证方式称为单向认证，通信双方都提供数字签名的认证方式称为双向认证。一般网银系统多采用单向认证方式，而要求较高的网银交易则都采用双向认证方式。
    PKI和PGP是现代网络安全技术领域的两把锁。目前电子商务、电子政务使用PKI技术来确保平台安全性。PGP则多用于电子邮件、文件等的数据签名与加密。

# 电子邮件传输算法--Base64

## Base64算法的由来

​	Base64算法并不是加密算法，仅仅是加密算法的近亲。Base64算法的转换方式很像古典加密算法中的单表置换算法。

   64算法最早应用于解决电子邮件传输的问题。在早期，由于“历史问题”，电子邮件只允许ASCII码字符。如果要传输一封带有非ASCII码字符的电子邮件，当它通过有“历史问题”的网关时就可能出现问题。这个网关很可能会对这个非ASCII码字符的二进制位做调整，即将这个非ASCII码的8位二进制码的最高位置为0。此时用户收到的邮件就会是一封纯粹的乱码邮件了。基于这个原因产生了Base64算法。

## Base64算法定义

​	Base64是一种基于64个字符的编码算法，根据RFC 2045（http://www.ietf.org/rfc/rfc2045.txt）的定义：“Base64内容传送编码是一种以任意8位字节序列组合的描述形式，这种形式不易被人直接识别（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.）”。经过Base64编码后的数据会比原始数据略长，为原来的4/3倍。经Base64编码后的字符串的字符数是以4为单位的整数倍。
​    RFC 2045还规定，在电子邮件中，每行为76个字符，每行末需添加一个回车换行符（"\r\n"），不论每行是否够76个字符，都要添加一个回车换行符。但在实际应用中，往往根据实际需要忽略了这一要求。
​    在RFC 2045文件中给出了表5-1所示的字符映射表：

![img](https://img-blog.csdnimg.cn/20190627224035475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExNzQ2OTk=,size_16,color_FFFFFF,t_70)

这张字符映射表中，Value指的是十进制编码，Encoding指的是字符，共映射了64个字符，这也是Base64算法命名的由来。映射表的最后一个字符是等号，它是用来补位的。也难怪有经验的读者朋友一看到字符串末尾有个等号，就会联想到Base64算法了。
其实，Base64算法还有几个同胞兄弟，如Base32和Base16算法。为了能在http请求中以Get方式传递二进制数据，由Base64算法衍生出了Url Base64算法。
    Url Base64算法主要是替换了Base64 字符映射表中的第62和63个字符，也就是将“+”和“/”符号替换成了“-”和“_”符号。但对于补位符“=”，一种建议是使用“~”符号，另一种建议是使用“.”符号。其中，由于“~”符号与文件系统冲突，不建议使用；而对于“.”符号，如果出现连续两次，则认为是错误。对于补位符的问题，Bouncy Castle和Commons Codec有差别：Bouncy Castle使用“.”作为补位符，而Commons Codec则完全杜绝使用补位符。

## 实现原理

Base64算法主要是对给定的字符以与字符编码（如ASCII码，UTF-8码）对应的十进制数为基准，做编码操作：
1）将给定的字符串以字符为单位转换为对应的字符编码（如ASCII码）。
2）将获得的字符编码转换为二进制码。
3）对获得的二进制码做分组转换操作，每3个8位二进制码为一组，转换为每4个6位二进制码为一组（不足6位时低位补0）。这是一个分组变化的过程，3个8位二进制码和4个6位二进制码的长度都是24位（3×8 = 4×6 = 24）。
4）对获得的4个6位二进制码补位，向6位二进制码添加2位高位0，组成4个8位二进制码。
5）将获得的4个8位二进制码转换为十进制码。
6）将获得的十进制码转换为Base64字符表中对应的字符。